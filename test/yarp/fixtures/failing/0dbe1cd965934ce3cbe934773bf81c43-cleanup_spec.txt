require "spec_helper"

RSpec.describe Asciidoctor::BSI do
   before(:all) do
  @blank_hdr = blank_hdr_gen
end

  it "removes empty text elements" do
    expect(xmlpp(strip_guid(Asciidoctor.convert(<<~"INPUT", backend: :bsi, header_footer: true)))).to be_equivalent_to xmlpp(<<~"OUTPUT")
      #{ASCIIDOC_BLANK_HDR}
      == {blank}
    INPUT
       #{@blank_hdr}
              <sections>
         <clause id="_" inline-header="false" obligation="normative">

       </clause>
       </sections>
       </bsi-standard>
    OUTPUT
  end

  it "processes stem-only terms as admitted" do
    expect(xmlpp(strip_guid(Asciidoctor.convert(<<~"INPUT", backend: :bsi, header_footer: true)))).to be_equivalent_to xmlpp(<<~"OUTPUT")
      #{ASCIIDOC_BLANK_HDR}
      == Terms and Definitions

      === stem:[t_90]

      stem:[t_91]

      Time
    INPUT
       #{@blank_hdr}
              <sections>
         <terms id="_" obligation="normative">
         <title>Terms and definitions</title>
         <p id="_">For the purposes of this British Standard, 
       the following terms and definitions apply.</p>
        #{TERMS_BOILERPLATE}
         <term id="term-t90"><preferred><stem type="MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mrow>
  <mi>t</mi>
</mrow>
<mrow>
  <mn>90</mn>
</mrow>
</msub></math></stem></preferred><admitted><stem type="MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mrow>
  <mi>t</mi>
</mrow>
<mrow>
  <mn>91</mn>
</mrow>
</msub></math></stem></admitted>
       <definition><p id="_">Time</p></definition></term>
       </terms>
       </sections>
       </bsi-standard>
    OUTPUT
  end

  it "permits multiple blocks in term definition paragraph" do
    expect(xmlpp(strip_guid(Asciidoctor.convert(<<~"INPUT", backend: :bsi, header_footer: true)))).to be_equivalent_to xmlpp(<<~"OUTPUT")
      = Document title
      Author
      :docfile: test.adoc
      :nodoc:
      :novalid:
      :stem:
      :no-isobib:

      == Terms and Definitions

      === stem:[t_90]

      [stem]
      ++++
      t_A
      ++++

      This paragraph is extraneous
    INPUT
       #{@blank_hdr}
              <sections>
         <terms id="_" obligation="normative">
         <title>Terms and definitions</title>
         <p id="_">For the purposes of this British Standard, 
       the following terms and definitions apply.</p>
        #{TERMS_BOILERPLATE}
         <term id="term-t90"><preferred><stem type="MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mrow>
  <mi>t</mi>
</mrow>
<mrow>
  <mn>90</mn>
</mrow>
</msub></math></stem></preferred><definition><formula id="_">
         <stem type="MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mrow>
  <mi>t</mi>
</mrow>
<mrow>
  <mi>A</mi>
</mrow>
</msub></math></stem>
       </formula><p id="_">This paragraph is extraneous</p></definition>
       </term>
       </terms>
       </sections>
       </bsi-standard>
    OUTPUT
  end

  it "keeps any initial boilerplate from terms and definitions" do
    expect(xmlpp(strip_guid(Asciidoctor.convert(<<~"INPUT", backend: :bsi, header_footer: true)))).to be_equivalent_to xmlpp(<<~"OUTPUT")
      #{ASCIIDOC_BLANK_HDR}
      == Terms and Definitions

      I am boilerplate

      * So am I

      === Time

      This paragraph is extraneous
    INPUT
       #{@blank_hdr}
              <sections>
         <terms id="_" obligation="normative"><title>Terms and definitions</title>
         <p id="_">For the purposes of this British Standard, 
       the following terms and definitions apply.</p>
        #{TERMS_BOILERPLATE}
<p id='_'>I am boilerplate</p>
<ul id='_'>
  <li>
    <p id='_'>So am I</p>
  </li>
</ul>
       <term id="term-time">
       <preferred>Time</preferred>
         <definition><p id="_">This paragraph is extraneous</p></definition>
       </term></terms>
       </sections>
       </bsi-standard>
    OUTPUT
  end

  it "strips type from xrefs" do
    expect(xmlpp(strip_guid(Asciidoctor.convert(<<~"INPUT", backend: :bsi, header_footer: true)))).to be_equivalent_to xmlpp(<<~"OUTPUT")
      #{ASCIIDOC_BLANK_HDR}
      <<iso216>>

      [bibliography]
      == Clause
      * [[[iso216,ISO 216]]], _Reference_
    INPUT
       #{@blank_hdr}
       <preface>
       <foreword id="_" obligation="informative">
         <title>FOREWORD</title>
         <p id="_">
         <eref type="inline" bibitemid="iso216" citeas="[1]"/>
       </p>
       </foreword></preface><sections>
       </sections><bibliography><references id="_" obligation="informative" normative="false">
  <title>Bibliography</title>
  <p id='_'>
  For dated references, only the edition cited applies. For undated
  references, the latest edition of the referenced document (including any
  amendments) applies.
</p>
  <bibitem id="iso216" type="standard">
  <title format="text/plain">Reference</title>
  <docidentifier type='metanorma'>[1]</docidentifier>
  <docidentifier>ISO 216</docidentifier>
  <docnumber>216</docnumber>
  <contributor>
    <role type="publisher"/>
    <organization>
      <name>International Organization for Standardization</name>
      <abbreviation>ISO</abbreviation>
    </organization>
  </contributor>
</bibitem>
</references></bibliography>
       </bsi-standard>
    OUTPUT
  end

  it "processes localities in term sources" do
    expect(xmlpp(strip_guid(Asciidoctor.convert(<<~"INPUT", backend: :bsi, header_footer: true)))).to be_equivalent_to xmlpp(<<~"OUTPUT")
      #{ASCIIDOC_BLANK_HDR}
      == Terms and Definitions

      === Term1

      [.source]
      <<ISO2191,section=1>>
      INPUT
              #{@blank_hdr}
       <sections>
         <terms id="_" obligation="normative">
         <title>Terms and definitions</title>
         <p id="_">For the purposes of this British Standard, the following terms and definitions apply.</p>
         #{TERMS_BOILERPLATE}
         <term id="term-term1">
         <preferred>Term1</preferred>
         <termsource status="identical">
         <origin bibitemid="ISO2191" type="inline" citeas="">
         <localityStack>
        <locality type="section"><referenceFrom>1</referenceFrom></locality>
         </localityStack>
        </origin>
       </termsource>
       </term>
       </terms>
       </sections>
       </bsi-standard>
      OUTPUT
  end

  it "removes extraneous material from Normative References" do
    expect(xmlpp(strip_guid(Asciidoctor.convert(<<~"INPUT", backend: :bsi, header_footer: true)))).to be_equivalent_to xmlpp(<<~"OUTPUT")
      #{ASCIIDOC_BLANK_HDR}
      [bibliography]
      == Normative References

      This is extraneous information

      * [[[iso216,ISO 216]]], _Reference_
    INPUT
      #{@blank_hdr}
      <sections></sections>
      <bibliography><references id="_" obligation="informative" normative="true"><title>Normative references</title>
      <p id="_">The following documents are referred to in the text in such a way that some or all of their content constitutes provisions of this document. For dated references, only the edition cited applies. For undated references, the latest edition of the referenced document (including any amendments) applies.</p>
             <bibitem id="iso216" type="standard">
         <title format="text/plain">Reference</title>
         <docidentifier type='metanorma'>[N1]</docidentifier>
         <docidentifier>ISO 216</docidentifier>
         <docnumber>216</docnumber>
         <contributor>
           <role type="publisher"/>
           <organization>
             <name>International Organization for Standardization</name>
             <abbreviation>ISO</abbreviation>
           </organization>
         </contributor>
       </bibitem>
      </references>
      </bibliography>
      </bsi-standard>
    OUTPUT
  end

  it "inserts IDs into paragraphs" do
    expect(xmlpp(strip_guid(Asciidoctor.convert(<<~"INPUT", backend: :bsi, header_footer: true)))).to be_equivalent_to xmlpp(<<~"OUTPUT")
      #{ASCIIDOC_BLANK_HDR}
      Paragraph
    INPUT
       #{@blank_hdr}
       <sections>
         <p id="_">Paragraph</p>
       </sections>
       </bsi-standard>
    OUTPUT
  end

  it "inserts IDs into notes" do
    expect(xmlpp(strip_guid(Asciidoctor.convert(<<~"INPUT", backend: :bsi, header_footer: true)))).to be_equivalent_to xmlpp(<<~"OUTPUT")
      #{ASCIIDOC_BLANK_HDR}
      [example]
      ====
      NOTE: This note has no ID
      ====
    INPUT
       #{@blank_hdr}
       <sections>
         <example id="_">
         <note id="_">
         <p id="_">This note has no ID</p>
       </note>
       </example>
       </sections>
       </bsi-standard>
    OUTPUT
  end

  it "moves footnotes inside figures" do
    expect(xmlpp(strip_guid(Asciidoctor.convert(<<~"INPUT", backend: :bsi, header_footer: true)))).to be_equivalent_to xmlpp(<<~"OUTPUT")
      #{ASCIIDOC_BLANK_HDR}
      image::spec/examples/rice_images/rice_image1.png[]

      footnote:[This is a footnote to a figure]

      footnote:[This is another footnote to a figure]
    INPUT
       #{@blank_hdr}
       <sections><figure id="_">
         <image src="spec/examples/rice_images/rice_image1.png" id="_" mimetype="image/png" height="auto" width="auto"/>
       <fn reference="A">
         <p id="_">This is a footnote to a figure</p>
       </fn><fn reference="B">
         <p id="_">This is another footnote to a figure</p>
       </fn></figure>

       </sections>

       </bsi-standard>
    OUTPUT
  end

   it "footnotes tables" do
    expect(xmlpp(strip_guid(Asciidoctor.convert(<<~"INPUT", backend: :bsi, header_footer: true)))).to be_equivalent_to xmlpp(<<~"OUTPUT")
      #{ASCIIDOC_BLANK_HDR}

      |===
      | a | b footnote:[footnote text]
      |===
    INPUT
       #{@blank_hdr}
       <sections>
       <table id='_'>
  <tbody>
    <tr>
      <td valign='top' align='left'>a</td>
      <td valign='top' align='left'>
        b
        <fn reference='A'>
          <p id='_'>footnote text</p>
        </fn>
      </td>
    </tr>
  </tbody>
</table>
       </sections>
       </bsi-standard>
    OUTPUT
  end

  it "defaults section obligations" do
    expect(xmlpp(strip_guid(Asciidoctor.convert(<<~"INPUT", backend: :bsi, header_footer: true)))).to be_equivalent_to xmlpp(<<~"OUTPUT")
      #{ASCIIDOC_BLANK_HDR}

      == Clause
      Text

      [appendix]
      == Clause

      Text
    INPUT
       #{@blank_hdr}
       <sections><clause id="_" inline-header="false" obligation="normative">
         <title>Clause</title>
         <p id="_">Text</p>
       </clause>
       </sections><annex id="_" inline-header="false" obligation="normative">
         <title>Clause</title>
         <p id="_">Text</p>
       </annex>
       </bsi-standard>
    OUTPUT
  end

  it "styles ordered lists" do
    expect(xmlpp(strip_guid(Asciidoctor.convert(<<~"INPUT", backend: :bsi, header_footer: true)))).to be_equivalent_to xmlpp(<<~"OUTPUT")
    #{ASCIIDOC_BLANK_HDR}

    == Clause1

    . A
    .. B
    ... C
    .... D
    ..... E
    ...... F
    ....... G
    ........ H

    [note]
    --
    . A
    .. B
    --

    . A
    .. B
    ... C
    .... D
    ..... E
    .. F
    .. G
    ... H
    .... I
    ..... J

    [note]
    --
    . A
    .. B
    --

    . A
    .. B
    ... C
    .... D
    ..... E

    INPUT
    #{@blank_hdr}
<sections>
           <clause id='_' inline-header='false' obligation='normative'>
             <title>Clause1</title>
             <ol id='_' type='alphabet'>
               <li>
                 <p id='_'>A</p>
                 <ol id='_' type='arabic'>
                   <li>
                     <p id='_'>B</p>
                     <ol id='_' type='roman'>
                       <li>
                         <p id='_'>C</p>
                         <ol id='_' type='alphabet'>
                           <li>
                             <p id='_'>D</p>
                             <ol id='_' type='arabic'>
                               <li>
                                 <p id='_'>E</p>
                                 <ol id='_' type='roman'>
                                   <li>
                                     <p id='_'>F</p>
                                     <ol id='_' type='alphabet'>
                                       <li>
                                         <p id='_'>G</p>
                                         <ol id='_' type='arabic'>
                                           <li>
                                             <p id='_'>H</p>
                                           </li>
                                         </ol>
                                       </li>
                                     </ol>
                                   </li>
                                 </ol>
                               </li>
                             </ol>
                           </li>
                         </ol>
                       </li>
                     </ol>
                   </li>
                 </ol>
               </li>
             </ol>
             <ol id='_' type='arabic'>
               <li>
                 <p id='_'>A</p>
                 <ol id='_' type='roman'>
                   <li>
                     <p id='_'>B</p>
                   </li>
                 </ol>
               </li>
             </ol>
             <ol id='_' type='roman'>
               <li>
                 <p id='_'>A</p>
                 <ol id='_' type='alphabet'>
                   <li>
                     <p id='_'>B</p>
                     <ol id='_' type='arabic'>
                       <li>
                         <p id='_'>C</p>
                         <ol id='_' type='roman'>
                           <li>
                             <p id='_'>D</p>
                             <ol id='_' type='alphabet'>
                               <li>
                                 <p id='_'>E</p>
                               </li>
                             </ol>
                           </li>
                         </ol>
                       </li>
                     </ol>
                   </li>
                   <li>
                     <p id='_'>F</p>
                   </li>
                   <li>
                     <p id='_'>G</p>
                     <ol id='_' type='arabic'>
                       <li>
                         <p id='_'>H</p>
                         <ol id='_' type='roman'>
                           <li>
                             <p id='_'>I</p>
                             <ol id='_' type='alphabet'>
                               <li>
                                 <p id='_'>J</p>
                               </li>
                             </ol>
                           </li>
                         </ol>
                       </li>
                     </ol>
                   </li>
                 </ol>
               </li>
             </ol>
             <ol id='_' type='alphabet'>
               <li>
                 <p id='_'>A</p>
                 <ol id='_' type='arabic'>
                   <li>
                     <p id='_'>B</p>
                   </li>
                 </ol>
               </li>
             </ol>
             <ol id='_' type='arabic'>
               <li>
                 <p id='_'>A</p>
                 <ol id='_' type='roman'>
                   <li>
                     <p id='_'>B</p>
                     <ol id='_' type='alphabet'>
                       <li>
                         <p id='_'>C</p>
                         <ol id='_' type='arabic'>
                           <li>
                             <p id='_'>D</p>
                             <ol id='_' type='roman'>
                               <li>
                                 <p id='_'>E</p>
                               </li>
                             </ol>
                           </li>
                         </ol>
                       </li>
                     </ol>
                   </li>
                 </ol>
               </li>
             </ol>
           </clause>
         </sections>
       </bsi-standard>
    OUTPUT
  end
end
