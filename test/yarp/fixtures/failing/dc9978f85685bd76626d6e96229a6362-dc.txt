module DC
  require 'forwardable'
  require 'yaml'
  require 'docker'

  module CLI
    def self.run
      project = Project.new
    
      if ARGV.empty?
        project.run
      else
        case ARGV.size
        when 1
          case ARGV.first
          when 'stop'
            project.group.stop
          when 'restart'
            project.group.stop
            project.group.start
          when 'rs'
            project.group.stop
            project.group.rebuild_images
            project.group.start
          when 'ri'
            project.rebuild_images
          end
        when 2
          case ARGV
          when ['rebuild', 'services']
            project.group.stop
            project.group.rebuild_images
            project.group.start
          when ['rebuild', 'images']
            project.rebuild_images
          end
        end
      end
    end
  end

  class Container
    def initialize name, ports: []
      @name = name
      @container = if ports.empty?
        Docker::Container.create name: name, Image: name
      else
        port_maps = ports.map do |port|
          if port.is_a? PortMap
            port
          else
            to, from = port.split ':'
            PortMap.new from: from, to: to
          end
        end
    
        Docker::Container.create(
          name: name, Image: name,
          ExposedPorts: port_maps.map do |map|
            ["#{map.internal_port}/tcp", {}]
          end.to_h,
          HostConfig: {
            PortBindings: port_maps.map do |map|
              array = [{ HostPort: map.external_port, HostIp: map.external_ip }]
              ["#{map.internal_port}/tcp", array]
            end.to_h
          }
        )
      end
    end
    
    attr_reader :name
    
    def internal_container
      @container
    end
    
    extend Forwardable
    delegate [:id, :start, :kill!, :remove] => :internal_container
    
    def destroy
      kill!.remove
    end
    
    class PortMap
      def initialize from:, to:, external_ip: '0.0.0.0'
        @internal_port = from.to_s
        @external_port = to.to_s
        @external_ip = external_ip
      end
    
      attr_reader :internal_port, :external_port, :external_ip
    end
  end

  class Group
    def initialize hash, directory:
      @hash = hash
      @images = hash.keys.map do |name|
        Image.new name, directory: "#{directory}/#{name}"
      end
    end
    
    attr_reader :images
    
    def containers
      @containers ||= create_containers
    end
    
    def build_missing_images
      @images.each do |image|
        image.build unless image.exist?
      end
    end
    
    def start
      network = Network.new
      containers.each { |container| network.connect container.id }
      containers.each &:start
    end
    
    def stop
      containers.each &:destroy
    end
    
    def rebuild_images
      images.each do |image|
        image.tag "before_rebuild.#{Time.now.to_i}"
        image.build
      end
    end
    
    private
      def create_containers
        @hash.map do |name, value|
          ports = if value.is_a?(Hash) && value['ports'].is_a?(Array)
                    value['ports']
                  else
                    []
                  end
    
          Container.new name, ports: ports
        end
      end
  end

  class Image
    class << self
      def all
        @all ||= {}
      end
    
      def [] name
        all[name]
      end
    
      def []= name, image
        all[name] = image
      end
    end
    
    def initialize name, directory: name
      @name = name
      @directory = directory
      self.class[name] = self
    end
    
    attr_reader :name
    
    def exist?
      Docker::Image.exist? @name
    end
    
    def build
      build_parent_image_if_available
      image = Docker::Image.build_from_dir @directory do |json|
        puts JSON.parse json
      end
      image.tag repo: @name
      image
    end
    
    def tag tag
      Docker::Image.get(@name).tag repo: @name, tag: tag
    end
    
    private
      def build_parent_image_if_available
        dockerfile = IO.read "#{@directory}/Dockerfile"
        from, image_name = dockerfile.each_line.first.split ' '
        fail from unless from == 'FROM'
    
        if image = self.class[image_name]
          unless image.exist?
            puts "Building parent image #{image.name}."
            image.build
          end
        end
      end
  end

  class Network
    def initialize name = 'common'
      @network = prepare_network_with_name name
    end
    
    def internal_network
      @network
    end
    
    extend Forwardable
    delegate [:id, :connect] => :internal_network
    
    def name
      @network.info['Name']
    end
    
    private
      def prepare_network_with_name name
        Docker::Network.get name
      rescue Docker::Error::NotFoundError
        Docker::Network.create name
      end
  end

  class Project
    def initialize directory: '.', docker_socket: 'tcp://127.0.0.1:2375'
      check_if_docker_is_available_at docker_socket
    
      @directory = File.expand_path directory
    
      @images_directory = "#{@directory}/.docker/images"
      @images = prepare_images
    
      @services_file = "#{@directory}/.docker/services.yml"
    end
    
    attr_reader :images, :group
    
    def containers
      group.containers
    end
    
    def run
      build_images
      prepare_services
    end
    
    def rebuild_images
      images.each do |image|
        image.tag "before_rebuild.#{Time.now.to_i}"
        image.build
      end
    end
    
    private
      def check_if_docker_is_available_at docker_socket
        Docker.url = docker_socket
        Docker.version
      #rescue Excon::Error::Socket
      end
    
      def prepare_images
        if Dir.exist? @images_directory
          (Dir.entries(@images_directory) - ['.', '..']).map do |name|
            Image.new name, directory: "#{@images_directory}/#{name}"
          end
        else
          []
        end
      end
    
      def build_images
        images.each do |image|
          image.build unless image.exist?
        end
      end
    
      def prepare_services
        if File.exist? @services_file
          @group = Group.new (YAML.load_file @services_file), directory: @directory
          @group.build_missing_images
          @group.start
        end
      end
  end
end
